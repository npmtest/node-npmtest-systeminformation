{"/home/travis/build/npmtest/node-npmtest-systeminformation/test.js":"/* istanbul instrument in package npmtest_systeminformation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-systeminformation/lib.npmtest_systeminformation.js":"/* istanbul instrument in package npmtest_systeminformation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_systeminformation = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_systeminformation = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-systeminformation/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-systeminformation && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_systeminformation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_systeminformation\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_systeminformation.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_systeminformation.rollup.js'] =\n            local.assetsDict['/assets.npmtest_systeminformation.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_systeminformation.__dirname + '/lib.npmtest_systeminformation.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/index.js":"'use strict';\n// ==================================================================================\n// index.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// Contributors:  Guillaume Legrain (https://github.com/glegrain)\n//                Riccardo Novaglia (https://github.com/richy24)\n//                Quentin Busuttil (https://github.com/Buzut)\n//                Lapsio (https://github.com/lapsio)\n//                csy (https://github.com/csy1983)\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n//\n// Sections\n// --------------------------------\n// 1. General\n// 2. System (HW)\n// 3. OS - Operating System\n// 4. CPU\n// 5. Memory\n// 6. Battery\n// 7. Graphics\n// 8. File System\n// 9. Network\n// 10. Processes\n// 11. Users/Sessions\n// 12. Internet\n// 13. Docker\n// 14. GetAll - get all data\n//\n// ==================================================================================\n//\n// Installation\n// --------------------------------\n//\n// # npm install systeminformation --save\n//\n// Since version 2.0 systeminformation has no more dependencies.\n//\n// ==================================================================================\n//\n// Usage\n// --------------------------------\n// All functions (except `version` and `time`) are asynchronous functions. Here a small example how to use them:\n//\n// var si = require('systeminformation');\n//\n// // callback style\n// si.cpu(function(data) {\n//\t  console.log('CPU-Information:');\n//\t  console.log(data);\n// })\n//\n// // promises style\n// si.cpu()\n// \t.then(data => console.log(data))\n// \t.catch(error => console.error(error));\n//\n// ==================================================================================\n//\n// Comments\n// --------------------------------\n//\n// This library is still work in progress. Version 3 comes with further improvements. First it\n// requires now node.js version 4.0 and above. Another big change is, that all functions now\n// return promises. You can use them like before with callbacks OR with promises (see documentation\n// below. I am sure, there is for sure room for improvement. I was only able to test it on several\n// Debian, Raspbian, Ubuntu distributions as well as OS X (Mavericks, Yosemite, El Captain).\n// Since version 2 nearly all functionality is available on OS X/Darwin platforms.\n// But be careful, this library will definitely NOT work on Windows platforms!\n//\n// Comments, suggestions & reports are very welcome!\n//\n// ==================================================================================\n//\n// Version history\n// --------------------------------\n//\n// version\tdate\t      comment\n// 3.17.2   2017-04-24  minor fix (removed console.log)\n// 3.17.1   2017-04-23  fixed bugs fsSize(win), si.processes (command), si.osinfo(win)\n// 3.17.0\t  2017-02-19\twindows support for some first functions\n// 3.16.0\t  2017-01-19\tblockDevices: added removable attribute + fix\n// 3.15.1\t  2017-01-17\tminor cpuTemperature fix (OSX)\n// 3.15.0\t  2017-01-15\tadded cpuTemperature also for OSX\n// 3.14.0\t  2017-01-14\tadded currentLoad per cpu/core, cpu cache (L1, L2, L3) and cpu flags\n// 3.13.0\t  2016-11-23\tadded shell (determines standard shell)\n// 3.12.0\t  2016-11-17\trefactoring and extended currentLoad (better OSX coverage and added irq load)\n// 3.11.2\t  2016-11-16\tblockDevices: improved for older lsblk versions\n// 3.11.1\t  2016-11-16\tfixed small bug in blockDevices\n// 3.11.0\t  2016-11-15\tblockDevices for OSX and extended blockDevices\n// 3.10.2\t  2016-11-14\tbug fix fsSize on OSX\n// 3.10.1\t  2016-11-14\toptimization fsStats, disksIO, networkStats\n// 3.10.0\t  2016-11-12\tadded blockDevices, fixed fsSize,  added file system type\n// 3.9.0\t  2016-11-11\tadded MAC address to networkInterfaces, fixed currentLoad\n// 3.8.1\t  2016-11-04\tupdated docs\n// 3.8.0\t  2016-11-04\tadded dockerContainerProcesses\n// 3.7.1\t  2016-11-03\tcode refactoring\n// 3.7.0\t  2016-11-02\textended docker stats, and no longer relying on curl (version conflicts)\n// 3.6.0\t  2016-09-16\tadded versions (kernel, ssl, node, npm, pm2, ...)\n// 3.5.1\t  2016-09-14\tbugfix graphics info\n// 3.5.0\t  2016-09-14\tadded graphics info (controller, display)\n// 3.4.4\t  2016-09-02\ttiny fixes system.model, getDefaultNetworkInterface\n// 3.4.3\t  2016-09-02\ttiny bug fix fsStats, disksIO OSX\n// 3.4.2\t  2016-09-01\timproved default network interface\n// 3.4.1\t  2016-08-30\tupdated docs\n// 3.4.0\t  2016-08-30\trewritten current process cpu usage (linux)\n// 3.3.0\t  2016-08-24\tadded process list\n// 3.2.1\t  2016-08-20\tupdated docs, improvement system\n// 3.2.0\t  2016-08-19\tadded battery info\n// 3.1.1\t  2016-08-18\timproved system and os detection (vm, ...), bug fix disksIO\n// 3.1.0\t  2016-08-18\tadded docker stats\n// 3.0.1\t  2016-08-17\tBug-Fix disksIO, users, updated docs\n// 3.0.0\t  2016-08-03\tnew major version 3.0\n// 2.0.5\t  2016-02-22\tsome more tiny correction ...\n// 2.0.4\t  2016-02-22\ttiny correction - removed double quotes CPU brand, ...\n// 2.0.3\t  2016-02-22\toptimized cpuCurrentspeed\n// 2.0.2\t  2016-02-22\tadded CoreOS identification\n// 2.0.1\t  2016-01-07\tminor patch\n// 2.0.0\t  2016-01-07\tnew major version 2.0\n// 1.0.7\t  2015-11-27\tfixed: si.network_speed()\n// 1.0.6\t  2015-09-17\tfixed: si.users()\n// 1.0.5\t  2015-09-14\tupdated dependencies\n// 1.0.4\t  2015-07-18\tupdated docs\n// 1.0.3\t  2015-07-18\tbugfix cpu cores\n// 1.0.2\t  2015-07-18\tbugfix cpu_currentspeed, cpu_temperature\n// 1.0.1\t  2015-07-18\tdocumentation update\n// 1.0.0\t  2015-07-18\tbug-fixes, version bump, published as npm component\n// 0.0.3\t  2014-04-14\tbug-fix (cpu_speed)\n// 0.0.2\t  2014-03-14\tOptimization FS-Speed & CPU current speed\n// 0.0.1\t  2014-03-13\tinitial release\n//\n// ==================================================================================\n\n// ----------------------------------------------------------------------------------\n// Dependencies\n// ----------------------------------------------------------------------------------\n\nconst os = require('os')\n  , fs = require('fs');\n\nconst lib_version = require('../package.json').version;\nconst util = require('./util');\nconst system = require('./system');\nconst osInfo = require('./osinfo');\nconst cpu = require('./cpu');\nconst mem = require('./memory');\nconst battery = require('./battery');\nconst graphics = require('./graphics');\nconst filesystem = require('./filesystem');\nconst network = require('./network');\nconst processes = require('./processes');\nconst users = require('./users');\nconst internet = require('./internet');\nconst docker = require('./docker');\n\nlet _platform = os.type();\nlet _windows = (_platform === 'Windows_NT');\n\nconst NOT_SUPPORTED = 'not supported';\n\n// ----------------------------------------------------------------------------------\n// 1. General\n// ----------------------------------------------------------------------------------\n\nfunction version() {\n  return lib_version;\n}\n\n// ----------------------------------------------------------------------------------\n// 14. get all\n// ----------------------------------------------------------------------------------\n\n// --------------------------\n// get static data - they should not change until restarted\n\nfunction getStaticData(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let data = {};\n\n      data.version = version();\n\n      system().then(res => {\n        data.system = res;\n        osInfo.osInfo().then(res => {\n          data.os = res;\n          osInfo.versions().then(res => {\n            data.versions = res;\n            cpu.cpu().then(res => {\n              data.cpu = res;\n              graphics.graphics().then(res => {\n                data.graphics = res;\n                network.networkInterfaces().then(res => {\n                  data.net = res;\n                  if (callback) { callback(data) }\n                  resolve(data);\n                })\n              })\n            })\n          })\n        })\n      })\n    });\n  });\n}\n\n// --------------------------\n// get all dynamic data - e.g. for monitoring agents\n// may take some seconds to get all data\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getDynamicData(srv, iface, callback) {\n\n  if (util.isFunction(iface)) {\n    callback = iface;\n    iface = '';\n  }\n  if (util.isFunction(srv)) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      iface = iface || network.getDefaultNetworkInterface();\n      srv = srv || '';\n\n      // use closure to track ƒ completion\n      let functionProcessed = (function () {\n        let totalFunctions = 14;\n\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) { callback(data) }\n            resolve(data);\n          }\n        };\n      })();\n\n      // var totalFunctions = 14;\n      // function functionProcessed() {\n      //   if (--totalFunctions === 0) {\n      //     if (callback) { callback(data) }\n      //     resolve(data);\n      //   }\n      // }\n\n      let data = {};\n\n      // get time\n      data.time = osInfo.time();\n\n      /**\n       * @namespace\n       * @property {Object}  versions\n       * @property {string}  versions.node\n       * @property {string}  versions.v8\n       */\n      data.node = process.versions.node;\n      data.v8 = process.versions.v8;\n\n      cpu.cpuCurrentspeed().then(res => {\n        data.cpuCurrentspeed = res;\n        functionProcessed();\n      });\n\n      users.users().then(res => {\n        data.users = res;\n        functionProcessed();\n      });\n\n      processes.processes().then(res => {\n        data.processes = res;\n        functionProcessed();\n      });\n\n      cpu.currentLoad().then(res => {\n        data.currentLoad = res;\n        functionProcessed();\n      });\n\n      cpu.cpuTemperature().then(res => {\n        data.temp = res;\n        functionProcessed();\n      });\n\n      network.networkStats(iface).then(res => {\n        data.networkStats = res;\n        functionProcessed();\n      });\n\n      network.networkConnections().then(res => {\n        data.networkConnections = res;\n        functionProcessed();\n      });\n\n      mem().then(res => {\n        data.mem = res;\n        functionProcessed();\n      });\n\n      battery().then(res => {\n        data.battery = res;\n        functionProcessed();\n      });\n\n      processes.services(srv).then(res => {\n        data.services = res;\n        functionProcessed();\n      });\n\n      filesystem.fsSize().then(res => {\n        data.fsSize = res;\n        functionProcessed();\n      });\n\n      filesystem.fsStats().then(res => {\n        data.fsStats = res;\n        functionProcessed();\n      });\n\n      filesystem.disksIO().then(res => {\n        data.disksIO = res;\n        functionProcessed();\n      });\n\n      internet.inetLatency().then(res => {\n        data.inetLatency = res;\n        functionProcessed();\n      });\n    });\n  });\n}\n\n// --------------------------\n// get all data at once\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getAllData(srv, iface, callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let data = {};\n\n      getStaticData().then(res => {\n        data = res;\n        getDynamicData(srv, iface).then(res => {\n          for (let key in res) {\n            if (res.hasOwnProperty(key)) {\n              data[key] = res[key];\n            }\n          }\n          if (callback) { callback(data) }\n          resolve(data);\n        });\n      })\n    });\n  });\n}\n\n// ----------------------------------------------------------------------------------\n// export all libs\n// ----------------------------------------------------------------------------------\n\nexports.version = version;\nexports.system = system;\n\nexports.time = osInfo.time;\nexports.osInfo = osInfo.osInfo;\nexports.versions = osInfo.versions;\nexports.shell = osInfo.shell;\n\nexports.cpu = cpu.cpu;\nexports.cpuFlags = cpu.cpuFlags;\nexports.cpuCache = cpu.cpuCache;\nexports.cpuCurrentspeed = cpu.cpuCurrentspeed;\nexports.cpuTemperature = cpu.cpuTemperature;\nexports.currentLoad = cpu.currentLoad;\nexports.fullLoad = cpu.fullLoad;\n\nexports.mem = mem;\n\nexports.battery = battery;\n\nexports.graphics = graphics.graphics;\n\nexports.fsSize = filesystem.fsSize;\nexports.blockDevices = filesystem.blockDevices;\nexports.fsStats = filesystem.fsStats;\nexports.disksIO = filesystem.disksIO;\n\nexports.networkInterfaceDefault = network.networkInterfaceDefault;\nexports.networkInterfaces = network.networkInterfaces;\nexports.networkStats = network.networkStats;\nexports.networkConnections = network.networkConnections;\n\nexports.services = processes.services;\nexports.processes = processes.processes;\nexports.processLoad = processes.processLoad;\n\nexports.users = users.users;\n\nexports.inetChecksite = internet.inetChecksite;\nexports.inetLatency = internet.inetLatency;\n\nexports.dockerContainers = docker.dockerContainers;\nexports.dockerContainerStats = docker.dockerContainerStats;\nexports.dockerContainerProcesses = docker.dockerContainerProcesses;\nexports.dockerAll = docker.dockerAll;\n\nexports.getStaticData = getStaticData;\nexports.getDynamicData = getDynamicData;\nexports.getAllData = getAllData;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/util.js":"'use strict';\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nlet _cores = 0;\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj){\n  let uniques=[];\n  let stringify={};\n  for(let i=0;i<obj.length;i++){\n    let keys=Object.keys(obj[i]);\n    keys.sort(function(a,b) {return a-b});\n    let str='';\n    for(let j=0;j<keys.length;j++){\n      str+= JSON.stringify(keys[j]);\n      str+= JSON.stringify(obj[i][keys[j]]);\n    }\n    if(!stringify.hasOwnProperty(str)){\n      uniques.push(obj[i]);\n      stringify[str]=true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function(a, b) {\n    let x ='';\n    let y ='';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey= sortByKey;\nexports.cores = cores;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/system.js":"'use strict';\n// ==================================================================================\n// system.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 2. System (Hardware)\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: 'Computer',\n        version: '',\n        serial: '-',\n        uuid: '-'\n      };\n\n      if (_linux) {\n        exec(\"dmidecode -t system\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              if (line.indexOf(':') !== -1) {\n                if (line.toLowerCase().indexOf('manufacturer') !== -1) result.manufacturer = result.manufacturer || line.split(':')[1].trim();\n                if (line.toLowerCase().indexOf('product name') !== -1) result.model = line.split(':')[1].trim();\n                if (line.toLowerCase().indexOf('version') !== -1) result.version = result.version || line.split(':')[1].trim();\n                if (line.toLowerCase().indexOf('serial number') !== -1) result.serial = line.split(':')[1].trim();\n                if (line.toLowerCase().indexOf('uuid') !== -1) result.uuid = line.split(':')[1].trim();\n              }\n            });\n            if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) result.serial = '-';\n            if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) result.manufacturer = '';\n            if (result.model.toLowerCase().indexOf('o.e.m.') !== -1) result.model = 'Computer';\n            if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) result.version = '-';\n\n            if (result.manufacturer === '' && result.model === 'Computer' && result.version === '-') {\n              // Check Raspberry Pi\n              exec(\"grep Hardware /proc/cpuinfo; grep Serial /proc/cpuinfo; grep Revision /proc/cpuinfo\", function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    if (line.indexOf(':') !== -1) {\n                      if (line.toLowerCase().indexOf('hardware') !== -1) result.model = line.split(':')[1].trim();\n                      if (line.toLowerCase().indexOf('revision') !== -1) result.version = line.split(':')[1].trim();\n                      if (line.toLowerCase().indexOf('serial') !== -1) result.serial = line.split(':')[1].trim();\n                    }\n                  });\n                  if (result.model === 'BCM2709') {\n                    result.manufacturer = 'Raspberry Pi Foundation';\n                    result.model = result.model + ' - Pi 2 Model B';\n                    if (['a01041', 'a21041'].indexOf(result.version) >= 0) {\n                      result.version = result.version + ' - Rev. 1.1'\n                    }\n                  }\n                  if (result.model === 'BCM2708') {\n                    result.manufacturer = 'Raspberry Pi Foundation';\n                    if (['0002', '0003'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model B';\n                      result.version = result.version + ' - Rev 1.0';\n                    }\n                    if (['0007', '0008', '0009'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model A';\n                      result.version = result.version + ' - Rev 2.0';\n                    }\n                    if (['0004', '0005', '0006', '000d', '000e', '000f'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model B';\n                      result.version = result.version + ' - Rev 2.0';\n                    }\n                    if (['0012'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model A+';\n                      result.version = result.version + ' - Rev 1.0';\n                    }\n                    if (['0010'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model B+';\n                      result.version = result.version + ' - Rev 1.0';\n                    }\n                    if (['0013'].indexOf(result.version) >= 0) {\n                      result.model = result.model + ' - Pi Model B+';\n                      result.version = result.version + ' - Rev 1.2';\n                    }\n                  }\n                }\n                if (callback) { callback(result) }\n                resolve(result);\n              })\n            } else {\n              if (callback) { callback(result) }\n              resolve(result);\n            }\n          } else {\n            exec(\"dmesg | grep -i virtual | grep -iE 'vmware|qemu|kvm|xen'\", function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                if (lines.length > 0) result.model = 'Virtual machine'\n              }\n              if (fs.existsSync('/.dockerenv') || fs.existsSync('/.dockerinit')) {\n                result.model = 'Docker Container'\n              }\n              if (callback) { callback(result) }\n              resolve(result);\n            });\n          }\n        })\n      }\n      if (_darwin) {\n        exec(\"ioreg -c IOPlatformExpertDevice -d 2\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              line = line.replace(/[<>\"]/g, \"\");\n              if (line.indexOf('=') !== -1) {\n                if (line.toLowerCase().indexOf('manufacturer') !== -1) result.manufacturer = line.split('=')[1].trim();\n                if (line.toLowerCase().indexOf('model') !== -1) result.model = line.split('=')[1].trim();\n                if (line.toLowerCase().indexOf('version') !== -1) result.version = line.split('=')[1].trim();\n                if (line.toLowerCase().indexOf('ioplatformserialnumber') !== -1) result.serial = line.split('=')[1].trim();\n                if (line.toLowerCase().indexOf('ioplatformuuid') !== -1) result.uuid = line.split('=')[1].trim();\n              }\n            });\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        })\n      }\n      if (_windows) {\n        exec(\"wmic csproduct get\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0)[0].trim().split(/\\s\\s+/);\n            result.manufacturer = lines[5];\n            result.model = lines[3];\n            result.version = lines[6];\n            result.serial = lines[2];\n            result.uuid = lines[4];\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        })\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/osinfo.js":"'use strict';\n// ==================================================================================\n// osinfo.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 3. Operating System\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\n// --------------------------\n// Get current time and OS uptime\n\nfunction time() {\n  return {\n    current: Date.now(),\n    uptime: os.uptime()\n  };\n}\n\nexports.time = time;\n\n// --------------------------\n// Get logo filename of OS distribution\n\nfunction getLogoFile(distro) {\n  distro = distro || '';\n  distro = distro.toLowerCase();\n  let result = 'linux';\n  if (_windows) {\n    result = 'windows'\n  }\n  else if (distro.indexOf('mac os') !== -1) {\n    result = 'apple'\n  }\n  else if (distro.indexOf('arch') !== -1) {\n    result = 'arch'\n  }\n  else if (distro.indexOf('centos') !== -1) {\n    result = 'centos'\n  }\n  else if (distro.indexOf('coreos') !== -1) {\n    result = 'coreos'\n  }\n  else if (distro.indexOf('debian') !== -1) {\n    result = 'debian'\n  }\n  else if (distro.indexOf('elementary') !== -1) {\n    result = 'elementary'\n  }\n  else if (distro.indexOf('fedora') !== -1) {\n    result = 'fedora'\n  }\n  else if (distro.indexOf('gentoo') !== -1) {\n    result = 'gentoo'\n  }\n  else if (distro.indexOf('mageia') !== -1) {\n    result = 'mageia'\n  }\n  else if (distro.indexOf('mandriva') !== -1) {\n    result = 'mandriva'\n  }\n  else if (distro.indexOf('manjaro') !== -1) {\n    result = 'manjaro'\n  }\n  else if (distro.indexOf('mint') !== -1) {\n    result = 'mint'\n  }\n  else if (distro.indexOf('openbsd') !== -1) {\n    result = 'openbsd'\n  }\n  else if (distro.indexOf('opensuse') !== -1) {\n    result = 'opensuse'\n  }\n  else if (distro.indexOf('pclinuxos') !== -1) {\n    result = 'pclinuxos'\n  }\n  else if (distro.indexOf('puppy') !== -1) {\n    result = 'puppy'\n  }\n  else if (distro.indexOf('raspbian') !== -1) {\n    result = 'raspbian'\n  }\n  else if (distro.indexOf('reactos') !== -1) {\n    result = 'reactos'\n  }\n  else if (distro.indexOf('redhat') !== -1) {\n    result = 'redhat'\n  }\n  else if (distro.indexOf('slackware') !== -1) {\n    result = 'slackware'\n  }\n  else if (distro.indexOf('sugar') !== -1) {\n    result = 'sugar'\n  }\n  else if (distro.indexOf('steam') !== -1) {\n    result = 'steam'\n  }\n  else if (distro.indexOf('suse') !== -1) {\n    result = 'suse'\n  }\n  else if (distro.indexOf('mate') !== -1) {\n    result = 'ubuntu-mate'\n  }\n  else if (distro.indexOf('lubuntu') !== -1) {\n    result = 'lubuntu'\n  }\n  else if (distro.indexOf('xubuntu') !== -1) {\n    result = 'xubuntu'\n  }\n  else if (distro.indexOf('ubuntu') !== -1) {\n    result = 'ubuntu'\n  }\n  return result;\n}\n\n// --------------------------\n// OS Information\n\nfunction osInfo(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n\n        platform: (_platform === 'Windows_NT' ? 'Windows' : _platform),\n        distro: 'unknown',\n        release: 'unknown',\n        codename: '',\n        kernel: os.release(),\n        arch: os.arch(),\n        hostname: os.hostname(),\n        logofile: ''\n      };\n\n      if (_linux) {\n\n        exec(\"cat /etc/*-release\", function (error, stdout) {\n          //if (!error) {\n          /**\n           * @namespace\n           * @property {string}  DISTRIB_ID\n           * @property {string}  NAME\n           * @property {string}  DISTRIB_RELEASE\n           * @property {string}  VERSION_ID\n           * @property {string}  DISTRIB_CODENAME\n           */\n          let release = {};\n          let lines = stdout.toString().split('\\n');\n          lines.forEach(function (line) {\n            if (line.indexOf('=') !== -1) {\n              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();\n            }\n          });\n          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/\"/g, '');\n          result.logofile = getLogoFile(result.distro);\n          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/\"/g, '');\n          result.codename = (release.DISTRIB_CODENAME || '').replace(/\"/g, '');\n          //}\n          if (callback) {\n            callback(result)\n          }\n          resolve(result);\n        })\n      }\n      if (_darwin) {\n        exec(\"sw_vers\", function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          lines.forEach(function (line) {\n            if (line.indexOf('ProductName') !== -1) {\n              result.distro = line.split(':')[1].trim();\n              result.logofile = getLogoFile(result.distro);\n            }\n            if (line.indexOf('ProductVersion') !== -1) result.release = line.split(':')[1].trim();\n          });\n          if (callback) {\n            callback(result)\n          }\n          resolve(result);\n        })\n      }\n      if (_windows) {\n        result.logofile = getLogoFile();\n        result.release = result.kernel;\n        exec(\"wmic os get Caption\", function (error, stdout) {\n          result.distro = result.codename = stdout.slice(stdout.indexOf('\\r\\n') + 2).trim();\n          if (callback) {\n            callback(result)\n          }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.osInfo = osInfo;\n\nfunction versions(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        kernel: os.release(),\n        node: process.versions.node,\n        v8: process.versions.v8,\n        npm: '',\n        pm2: '',\n        openssl: process.versions.openssl\n      };\n      let lines = [];\n      exec(\"npm -v\", function (error, stdout) {\n        if (!error) {\n          result.npm = stdout.toString().split('\\n')[0];\n        }\n        exec(\"pm2 -v\", function (error, stdout) {\n          if (!error) {\n            lines = stdout.toString().split('\\n');\n            if (lines.length >= 2) {\n              result.pm2 = lines[lines.length - 2];\n            }\n          }\n          if (callback) {\n            callback(result)\n          }\n          resolve(result);\n        });\n      });\n    });\n  });\n}\n\nexports.versions = versions;\n\nfunction shell(callback) {\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED)\n        }\n        reject(error);\n      }\n\n      let result = '';\n      exec(\"echo $SHELL\", function (error, stdout) {\n        if (!error) {\n          result = stdout.toString().split('\\n')[0];\n        }\n        if (callback) {\n          callback(result)\n        }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.shell = shell;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/cpu.js":"'use strict';\n// ==================================================================================\n// cpu.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 4. CPU\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nlet _cpu_speed = '0.00';\nlet _current_cpu = {\n  user: 0,\n  nice: 0,\n  system: 0,\n  idle: 0,\n  irq: 0,\n  load: 0,\n  tick: 0,\n  ms: 0,\n  currentload: 0,\n  currentload_user: 0,\n  currentload_nice: 0,\n  currentload_system: 0,\n  currentload_irq: 0\n};\nlet _cpus = [];\nlet _corecount = 0;\n\nfunction cpuBrandManufacturer(res) {\n  res.brand = res.brand.replace(/\\(R\\)+/g, \"®\");\n  res.brand = res.brand.replace(/\\(TM\\)+/g, \"™\");\n  res.brand = res.brand.replace(/\\(C\\)+/g, \"©\");\n  res.brand = res.brand.replace(/CPU+/g, \"\").trim();\n  res.manufacturer = res.brand.split(' ')[0];\n\n  let parts = res.brand.split(' ');\n  parts.shift();\n  res.brand = parts.join(' ');\n  return res;\n}\n\n// --------------------------\n// CPU - brand, speed\n\nfunction getCpu() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        manufacturer: 'unknown',\n        brand: 'unknown',\n        speed: '0.00',\n        cores: util.cores()\n      };\n      if (_darwin) {\n        exec(\"sysctl -n machdep.cpu.brand_string\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.brand = lines[0].split('@')[0].trim();\n            result.speed = lines[0].split('@')[1].trim();\n            result.speed = parseFloat(result.speed.replace(/GHz+/g, \"\"));\n            _cpu_speed = result.speed;\n          }\n          result = cpuBrandManufacturer(result);\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        exec(\"cat /proc/cpuinfo | grep 'model name'\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            let line = lines[0].split(':')[1];\n            result.brand = line.split('@')[0].trim();\n            result.speed = line.split('@')[1] ? parseFloat(line.split('@')[1].trim()).toFixed(2) : '0.00';\n            if (result.speed === '0.00') {\n              let current = getCpuCurrentSpeedSync();\n              if (current !== '0.00') result.speed = current;\n            }\n            _cpu_speed = result.speed;\n          }\n          result = cpuBrandManufacturer(result);\n          resolve(result);\n        })\n      }\n      if (_windows) {\n        exec(\"wmic cpu get name\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n            let line = (lines && lines[0]) ? lines[0] : '';\n            result.brand = line.split('@')[0].trim();\n            result.speed = line.split('@')[1].trim();\n            result.speed = parseFloat(result.speed.replace(/GHz+/g, \"\"));\n            _cpu_speed = result.speed;\n          }\n          result = cpuBrandManufacturer(result);\n          resolve(result);\n        })\n      }\n    });\n  });\n}\n\n// --------------------------\n// CPU - Processor Data\n\nfunction cpu(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      getCpu().then(result => {\n        if (callback) { callback(result) }\n        resolve(result);\n      })\n    });\n  });\n}\n\nexports.cpu = cpu;\n\n// --------------------------\n// CPU - current speed - in GHz\n\nfunction getCpuCurrentSpeedSync() {\n\n  let cpus = os.cpus();\n  let minFreq = 999999999;\n  let maxFreq = 0;\n  let avgFreq = 0;\n\n  if (cpus.length) {\n    for (let i in cpus) {\n      if (cpus.hasOwnProperty(i)) {\n        avgFreq = avgFreq + cpus[i].speed;\n        if (cpus[i].speed > maxFreq) maxFreq = cpus[i].speed;\n        if (cpus[i].speed < minFreq) minFreq = cpus[i].speed;\n      }\n    }\n    avgFreq = avgFreq / cpus.length;\n    return {\n      min: parseFloat((minFreq / 1000).toFixed(2)),\n      max: parseFloat((maxFreq / 1000).toFixed(2)),\n      avg: parseFloat((avgFreq / 1000).toFixed(2))\n    }\n  } else {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0\n    }\n  }\n}\n\nfunction cpuCurrentspeed(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getCpuCurrentSpeedSync();\n      if (result === 0 && _cpu_speed !== '0.00') result = parseFloat(_cpu_speed);\n\n      if (callback) { callback(result) }\n      resolve(result);\n    });\n  });\n}\n\nexports.cpuCurrentspeed = cpuCurrentspeed;\n\n// --------------------------\n// CPU - temperature\n// if sensors are installed\n\nfunction cpuTemperature(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      let result = {\n        main: -1.0,\n        cores: [],\n        max: -1.0\n      };\n      if (_linux) {\n        exec(\"sensors\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let regex = /\\+([^°]*)/g;\n              let temps = line.match(regex);\n              if (line.split(':')[0].toUpperCase().indexOf('PHYSICAL') !== -1) {\n                result.main = parseFloat(temps);\n              }\n              if (line.split(':')[0].toUpperCase().indexOf('CORE ') !== -1) {\n                result.cores.push(parseFloat(temps));\n              }\n            });\n            if (result.cores.length > 0) {\n              let maxtmp = Math.max.apply(Math, result.cores);\n              result.max = (maxtmp > result.main) ? maxtmp : result.main;\n            }\n            if (callback) { callback(result) }\n            resolve(result);\n          } else {\n            fs.stat('/sys/class/thermal/thermal_zone0/temp', function(err, stat) {\n              if(err === null) {\n                exec(\"cat /sys/class/thermal/thermal_zone0/temp\", function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    if (lines.length > 0) {\n                      result.main = parseFloat(lines[0]) / 1000.0;\n                      result.max = result.main\n                    }\n                  }\n                  if (callback) { callback(result) }\n                  resolve(result);\n                });\n              } else {\n                exec(\"/opt/vc/bin/vcgencmd measure_temp\", function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    if (lines.length > 0 && lines[0].indexOf('=')) {\n                      result.main = parseFloat(lines[0].split(\"=\")[1]);\n                      result.max = result.main\n                    }\n                  }\n                  if (callback) { callback(result) }\n                  resolve(result);\n                });\n              }\n            });\n\n          }\n        });\n      }\n      if (_darwin) {\n        let smc = require('../build/Release/smc');\n\n        let cores = ['TC0P', 'TC1C', 'TC2C', 'TC3C', 'TC4C', 'TC5C', 'TC6C', 'TC7C', 'TC8C'];\n        let sum = 0;\n        let id = 0;\n        cores.forEach(function(key) {\n          let value = smc.get(key);\n          if (id === 0) {\n            if (value > 0) {\n              result.main = value;\n              result.max = value;\n            }\n            id = 1;\n          } else {\n            if (value > 0) {\n              result.cores.push(value);\n              sum = sum + value;\n              if (value > result.max) result.max = value;\n            }\n          }\n        });\n        if (result.cores.length) {\n          result.main = sum / result.cores.length;\n        }\n\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n      if (_windows) {\n        exec(\"wmic /namespace:\\\\\\\\root\\\\wmi PATH MSAcpi_ThermalZoneTemperature get CriticalTripPoint,CurrentTemperature /value\", function (error, stdout) {\n          if (!error) {\n            let sum = 0;\n            let lines = stdout.trim().split(/\\s\\s+/);\n            lines.forEach(function (line) {\n              if (line.match('CriticalTripPoint') && !result.max)\n                result.max = (parseInt(line.split('CriticalTripPoint=')[1]) - 2732) / 10;\n              else if (line.match('CurrentTemperature')) {\n                let value = (parseInt(line.split('CurrentTemperature=')[1]) - 2732) / 10;\n                sum = sum + value;\n                result.cores.push(value);\n              }\n            });\n            if (result.cores.length) {\n              result.main = sum / result.cores.length;\n            }\n            if (callback) { callback(result) }\n            resolve(result);\n          }\n        });\n      }\n    });\n  });\n}\n\nexports.cpuTemperature = cpuTemperature;\n\n// --------------------------\n// CPU Flags\n\nfunction cpuFlags(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = '';\n      if (_linux) {\n        exec(\"lscpu\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              if (line.split(':')[0].toUpperCase().indexOf('FLAGS') !== -1) {\n                result = line.split(':')[1].trim().toLowerCase();\n              }\n            });\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec(\"sysctl machdep.cpu.features\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0 && lines[0].indexOf('machdep.cpu.features:') !== -1) {\n              result = lines[0].split(':')[1].trim().toLowerCase();\n            }\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.cpuFlags = cpuFlags;\n\n// --------------------------\n// CPU Flags\n\nfunction cpuCache(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = {};\n      if (_linux) {\n        exec(\"lscpu\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let parts = line.split(':');\n              if (parts[0].toUpperCase().indexOf('L1D CACHE') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toUpperCase().indexOf('L1I CACHE') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toUpperCase().indexOf('L2 CACHE') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toUpperCase().indexOf('L3 CACHE') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec(\"sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let parts = line.split(':');\n              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.cpuCache = cpuCache;\n\n// --------------------------\n// CPU - current load - in %\n\nfunction getLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let loads = os.loadavg().map(function (x) { return x / util.cores() });\n      let avgload = parseFloat((Math.max.apply(Math, loads)).toFixed(2));\n      let result = {};\n\n      let now = Date.now() - _current_cpu.ms;\n      if (now >= 200) {\n        _current_cpu.ms = Date.now();\n        const cpus = os.cpus();\n        let totalUser = 0;\n        let totalSystem = 0;\n        let totalNice = 0;\n        let totalIrq = 0;\n        let totalIdle = 0;\n        let cores = [];\n        _corecount = cpus.length;\n\n        for (let i = 0; i < _corecount; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIrq += cpu.irq;\n          totalIdle += cpu.idle;\n          let tmp_tick = (_cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0);\n          let tmp_load = (_cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0);\n          let tmp_user = (_cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0);\n          let tmp_system = (_cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0);\n          let tmp_nice = (_cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0);\n          let tmp_irq = (_cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0);\n          _cpus[i] = cpu;\n          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;\n          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;\n          _cpus[i].currentTick = _cpus[i].totalTick - tmp_tick;\n          _cpus[i].load = (_cpus[i].totalLoad - tmp_load) / _cpus[i].currentTick * 100;\n          _cpus[i].load_user = (_cpus[i].user - tmp_user) / _cpus[i].currentTick * 100;\n          _cpus[i].load_system = (_cpus[i].sys - tmp_system) / _cpus[i].currentTick * 100;\n          _cpus[i].load_nice = (_cpus[i].nice - tmp_nice) / _cpus[i].currentTick * 100;\n          _cpus[i].load_irq = (_cpus[i].irq - tmp_irq) / _cpus[i].currentTick * 100;\n          cores[i] = {};\n          cores[i].load = _cpus[i].load;\n          cores[i].load_user = _cpus[i].load_user;\n          cores[i].load_system = _cpus[i].load_system;\n          cores[i].load_nice = _cpus[i].load_nice;\n          cores[i].load_irq = _cpus[i].load_irq;\n        }\n        let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;\n        let totalLoad = totalUser + totalSystem + totalNice + totalIrq;\n        let currentTick = totalTick - _current_cpu.tick;\n        result = {\n          avgload: avgload,\n          currentload: (totalLoad - _current_cpu.load) / currentTick * 100,\n          currentload_user: (totalUser - _current_cpu.user) / currentTick * 100,\n          currentload_system: (totalSystem - _current_cpu.system) / currentTick * 100,\n          currentload_nice: (totalNice - _current_cpu.nice) / currentTick * 100,\n          currentload_irq: (totalIrq - _current_cpu.irq) / currentTick * 100,\n          cpus: cores\n        };\n        _current_cpu = {\n          user: totalUser,\n          nice: totalNice,\n          system: totalSystem,\n          idle: totalIdle,\n          irq: totalIrq,\n          tick: totalTick,\n          load: totalLoad,\n          ms: _current_cpu.ms,\n          currentload: result.currentload,\n          currentload_user: result.currentload_user,\n          currentload_system: result.currentload_system,\n          currentload_nice: result.currentload_nice,\n          currentload_irq: result.currentload_irq,\n        };\n      } else {\n        let cores = [];\n        for (let i = 0; i < _corecount; i++) {\n          cores[i] = {};\n          cores[i].load = _cpus[i].load;\n          cores[i].load_user = _cpus[i].load_user;\n          cores[i].load_system = _cpus[i].load_system;\n          cores[i].load_nice = _cpus[i].load_nice;\n          cores[i].load_irq = _cpus[i].load_irq;\n        }\n        result = {\n          avgload: avgload,\n          currentload: _current_cpu.currentload,\n          currentload_user: _current_cpu.currentload_user,\n          currentload_system: _current_cpu.currentload_system,\n          currentload_nice: _current_cpu.currentload_nice,\n          currentload_irq: _current_cpu.currentload_irq,\n          cpus: cores\n        };\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction currentLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getLoad().then(result => {\n        if (callback) { callback(result) }\n        resolve(result);\n      })\n    });\n  });\n}\n\nexports.currentLoad = currentLoad;\n\n// --------------------------\n// PS - full load\n// since bootup\n\nfunction getFullLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const cpus = os.cpus();\n      let totalUser = 0;\n      let totalSystem = 0;\n      let totalNice = 0;\n      let totalIrq = 0;\n      let totalIdle = 0;\n\n      for (let i = 0, len = cpus.length; i < len; i++) {\n        const cpu = cpus[i].times;\n        totalUser += cpu.user;\n        totalSystem += cpu.sys;\n        totalNice += cpu.nice;\n        totalIrq += cpu.irq;\n        totalIdle += cpu.idle;\n      }\n      let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;\n      let result = (totalTicks - totalIdle) / totalTicks * 100.0;\n\n      resolve(result);\n    });\n  });\n}\n\nfunction fullLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getFullLoad().then(result => {\n        if (callback) { callback(result) }\n        resolve(result);\n      })\n    });\n  });\n}\n\nexports.fullLoad = fullLoad;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/memory.js":"'use strict';\n// ==================================================================================\n// memory.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 5. Memory\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\n// _______________________________________________________________________________________\n// |                         R A M                              |          H D           |\n// |______________________|_________________________|           |                        |\n// |        active             buffers/cache        |           |                        |\n// |________________________________________________|___________|_________|______________|\n// |                     used                            free   |   used       free      |\n// |____________________________________________________________|________________________|\n// |                        total                               |          swap          |\n// |____________________________________________________________|________________________|\n\n// free (older versions)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers     cached\n// Mem:         16038 (1)   15653 (2)   384 (3)  0 (4)     236 (5)     14788 (6)\n// -/+ buffers/cache:       628 (7)     15409 (8)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// | active (2-(5+6) = 7) |  available (3+5+6 = 8)              |\n// |______________________|_________________________|___________|\n// |        active        |  buffers/cache (5+6)    |           |\n// |________________________________________________|___________|\n// |                   used (2)                     | free (3)  |\n// |____________________________________________________________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n\n//\n// free (since free von procps-ng 3.3.10)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers/cache   available\n// Mem:         16038 (1)   628 (2)     386 (3)  0 (4)     15024 (5)     14788 (6)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// |                      |      available (6) estimated        |\n// |______________________|_________________________|___________|\n// |     active (2)       |   buffers/cache (5)     | free (3)  |\n// |________________________________________________|___________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n//\n// Reference: http://www.software-architect.net/blog/article/date/2015/06/12/-826c6e5052.html\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n\n      let result = {\n        total: os.totalmem(),\n        free: os.freemem(),\n        used: os.totalmem() - os.freemem(),\n\n        active: os.totalmem() - os.freemem(),     // temporarily (fallback)\n        available: os.freemem(),                  // temporarily (fallback)\n        buffcache: 0,\n\n        swaptotal: 0,\n        swapused: 0,\n        swapfree: 0\n      };\n\n      if (_linux) {\n        exec(\"free -b\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            let mem = lines[1].replace(/ +/g, \" \").split(' ');\n            result.total = parseInt(mem[1]);\n            result.free = parseInt(mem[3]);\n\n            if (lines.length === 4) {                   // free (since free von procps-ng 3.3.10)\n              result.buffcache = parseInt(mem[5]);\n              result.available = parseInt(mem[6]);\n              mem = lines[2].replace(/ +/g, \" \").split(' ');\n            } else {                                    // free (older versions)\n              result.buffcache = parseInt(mem[5]) + parseInt(mem[6]);\n              result.available = result.free + result.buffcache;\n              mem = lines[3].replace(/ +/g, \" \").split(' ');\n            }\n            result.active = result.total - result.free - result.buffcache;\n\n            result.swaptotal = parseInt(mem[1]);\n            result.swapfree = parseInt(mem[3]);\n            result.swapused = parseInt(mem[2]);\n\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec(\"vm_stat | grep 'Pages active'\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            result.active = parseInt(lines[0].split(':')[1]) * 4096;\n            result.buffcache = result.used - result.active;\n            result.available = result.free + result.buffcache;\n          }\n          exec(\"sysctl -n vm.swapusage\", function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              if (lines.length > 0) {\n                let line = lines[0].replace(/,/g, \".\").replace(/M/g, \"\");\n                line = line.trim().split('  ');\n                for (let i = 0; i < line.length; i++) {\n                  if (line[i].toLowerCase().indexOf('total') !== -1) result.swaptotal = parseFloat(line[i].split('=')[1].trim()) * 1024 * 1024;\n                  if (line[i].toLowerCase().indexOf('used') !== -1) result.swapused = parseFloat(line[i].split('=')[1].trim()) * 1024 * 1024;\n                  if (line[i].toLowerCase().indexOf('free') !== -1) result.swapfree = parseFloat(line[i].split('=')[1].trim()) * 1024 * 1024;\n\n                }\n              }\n            }\n            if (callback) { callback(result) }\n            resolve(result);\n          });\n        });\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/battery.js":"'use strict';\n// ==================================================================================\n// battery.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 6. Battery\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = {\n        hasbattery: false,\n        cyclecount: 0,\n        ischarging: false,\n        maxcapacity: 0,\n        currentcapacity: 0,\n        percent: 0\n      };\n\n      if (_linux) {\n        let battery_path = '';\n        if (fs.existsSync('/sys/class/power_supply/BAT1/status')) {\n          battery_path = '/sys/class/power_supply/BAT1/'\n        } else if (fs.existsSync('/sys/class/power_supply/BAT0/status')) {\n          battery_path = '/sys/class/power_supply/BAT0/'\n        }\n        if (battery_path) {\n          exec(\"cat \" + battery_path + \"status\", function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              if (lines.length > 0 && lines[0]) result.ischarging = (lines[0].trim().toLowerCase() === 'charging')\n            }\n            exec(\"cat \" + battery_path + \"cyclec_ount\", function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                if (lines.length > 0 && lines[0]) result.cyclecount = parseFloat(lines[0].trim());\n              }\n              exec(\"cat \" + battery_path + \"charge_full\", function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  if (lines.length > 0 && lines[0]) result.maxcapacity = parseFloat(lines[0].trim());\n                }\n                exec(\"cat \" + battery_path + \"charge_now\", function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    if (lines.length > 0 && lines[0]) result.currentcapacity = parseFloat(lines[0].trim());\n                  }\n                  if (result.maxcapacity && result.currentcapacity) {\n                    result.hasbattery = true;\n                    result.percent = 100.0 * result.currentcapacity / result.maxcapacity;\n                  }\n                  if (callback) { callback(result) }\n                  resolve(result);\n                })\n              })\n            })\n          })\n        } else {\n          if (callback) { callback(result) }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        exec(\"ioreg -n AppleSmartBattery -r | grep '\\\"CycleCount\\\"';ioreg -n AppleSmartBattery -r | grep '\\\"IsCharging\\\"';ioreg -n AppleSmartBattery -r | grep '\\\"MaxCapacity\\\"';ioreg -n AppleSmartBattery -r | grep '\\\"CurrentCapacity\\\"'\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/ +/g, \"\").replace(/\"+/g, \"\").split('\\n');\n            lines.forEach(function (line) {\n              if (line.indexOf('=') !== -1) {\n                if (line.toLowerCase().indexOf('cyclecount') !== -1) result.cyclecount = parseFloat(line.split('=')[1].trim());\n                if (line.toLowerCase().indexOf('ischarging') !== -1) result.ischarging = (line.split('=')[1].trim().toLowerCase() === 'yes');\n                if (line.toLowerCase().indexOf('maxcapacity') !== -1) result.maxcapacity = parseFloat(line.split('=')[1].trim());\n                if (line.toLowerCase().indexOf('currentcapacity') !== -1) result.currentcapacity = parseFloat(line.split('=')[1].trim());\n              }\n            });\n          }\n          if (result.maxcapacity && result.currentcapacity) {\n            result.hasbattery = true;\n            result.percent = 100.0 * result.currentcapacity / result.maxcapacity;\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/graphics.js":"'use strict';\n// ==================================================================================\n// graphics.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 7. Graphics (controller, display)\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nfunction graphics(callback) {\n\n  function parseLinesDarwin(lines) {\n    let starts = [];\n    let level = -1;\n    let lastlevel = -1;\n    let controllers = [];\n    let displays = [];\n    let currentController = {};\n    let currentDisplay = {};\n    for (let i = 0; i < lines.length; i++) {\n      if ('' !== lines[i].trim()) {\n        let start = lines[i].search(/\\S|$/);\n        if (-1 === starts.indexOf(start)) {\n          starts.push(start);\n        }\n        level = starts.indexOf(start);\n        if (level < lastlevel) {\n          if (Object.keys(currentController).length > 0) {// just changed to Displays\n            controllers.push(currentController);\n            currentController = {};\n          }\n          if (Object.keys(currentDisplay).length > 0) {// just changed to Displays\n            displays.push(currentDisplay);\n            currentDisplay = {};\n          }\n        }\n        lastlevel = level;\n        let parts = lines[i].split(':');\n        if (2 === level) {       // grafics controller level\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('chipsetmodel') !== -1) currentController.model = parts[1].trim();\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('bus') !== -1) currentController.bus = parts[1].trim();\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('vendor') !== -1) currentController.vendor = parts[1].split('(')[0].trim();\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('vram(total)') !== -1) {\n            currentController.vram = parseInt(parts[1]);    // in MB\n            currentController.vramDynamic = false;\n          }\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('vram(dynamic,max)') !== -1) {\n            currentController.vram = parseInt(parts[1]);    // in MB\n            currentController.vramDynamic = true;\n          }\n        }\n        if (3 === level) {       // display controller level\n          if (parts.length > 1 && '' === parts[1]) {\n            currentDisplay.model = parts[0].trim();\n            currentDisplay.main = false;\n            currentDisplay.builtin = false;\n            currentDisplay.connection = '';\n            currentDisplay.sizex = -1;\n            currentDisplay.sizey = -1;\n          }\n        }\n        if (4 === level) {       // display controller details level\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('resolution') !== -1) {\n            let resolution = parts[1].split('x');\n            currentDisplay.resolutionx = (resolution.length > 1 ? parseInt(resolution[0]) : 0);\n            currentDisplay.resolutiony = (resolution.length > 1 ? parseInt(resolution[1]) : 0);\n          }\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('pixeldepth') !== -1) currentDisplay.pixeldepth = parseInt(parts[1]); // in BIT\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('maindisplay') !== -1 && parts[1].replace(/ +/g, \"\").toLowerCase() === 'yes') currentDisplay.main = true;\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('built-in') !== -1 && parts[1].replace(/ +/g, \"\").toLowerCase() === 'yes') {\n            currentDisplay.builtin = true;\n            currentDisplay.connection = '';\n          }\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('connectiontype') !== -1) {\n            currentDisplay.builtin = false;\n            currentDisplay.connection = parts[1].trim();\n          }\n        }\n      }\n    }\n    if (Object.keys(currentController).length > 0) {// just changed to Displays\n      controllers.push(currentController);\n    }\n    if (Object.keys(currentDisplay).length > 0) {// just changed to Displays\n      displays.push(currentDisplay);\n    }\n    return ({\n      controllers: controllers,\n      displays: displays\n    })\n  }\n\n  function parseLinesLinuxControllers(lines) {\n    let controllers = [];\n    let currentController = {};\n    let is_vga = false;\n    for (let i = 0; i < lines.length; i++) {\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0]) {        // first line of new entry\n          let vgapos = lines[i].toLowerCase().indexOf('vga');\n          if (vgapos !== -1) {         // VGA\n            if (Object.keys(currentController).length > 0) {// already a controller found\n              controllers.push(currentController);\n              currentController = {};\n            }\n            is_vga = true;\n            let endpos = lines[i].search(/\\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);\n            let parts = lines[i].substr(vgapos, endpos - vgapos).split(':');\n            if (parts.length > 1) {\n              parts[1] = parts[1].trim();\n              if (parts[1].toLowerCase().indexOf('corporation')) {\n                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf('corporation') + 11).trim();\n                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf('corporation') + 11, 200).trim().split('(')[0];\n                currentController.bus = '';\n                currentController.vram = -1;\n                currentController.vramDynamic = false;\n              }\n            }\n\n          } else {\n            is_vga = false;\n          }\n        }\n        if (is_vga) { // within VGA details\n          let parts = lines[i].split(':');\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('devicename') !== -1 && parts[0].toLowerCase().indexOf('onboard') !== -1)  currentController.bus = 'Onboard';\n          if (parts.length > 1 && parts[0].replace(/ +/g, \"\").toLowerCase().indexOf('region') !== -1 && parts[1].toLowerCase().indexOf('memory') !== -1) {\n            let memparts = parts[1].split(\"=\");\n            if (memparts.length > 1) {\n              currentController.vram = parseInt(memparts[1]);\n            }\n          }\n        }\n      }\n    }\n    if (Object.keys(currentController).length > 0) {// still controller information available\n      controllers.push(currentController);\n    }\n    return (controllers)\n  }\n\n  function parseLinesLinuxEdid(edid) {\n    // parsen EDID\n    // --> model\n    // --> resolutionx\n    // --> resolutiony\n    // --> builtin = false\n    // --> pixeldepth (?)\n    // --> sizex\n    // --> sizey\n    let result = {};\n    // find first \"Detailed Timing Description\"\n    let start = 108;\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    result.resolutionx = parseInt('0x0' + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));\n    result.resolutiony = parseInt('0x0' + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));\n    result.sizex = parseInt('0x0' + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));\n    result.sizey = parseInt('0x0' + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));\n    // monitor name\n    start = edid.indexOf('000000fc00'); // find first \"Monitor Description Data\"\n    if (start >= 0) {\n      let model_raw = edid.substr(start + 10, 26);\n      if (model_raw.indexOf('0a') !== -1) {\n        model_raw = model_raw.substr(0, model_raw.indexOf('0a'))\n      }\n      result.model = model_raw.match(/.{1,2}/g).map(function (v) {\n        return String.fromCharCode(parseInt(v, 16));\n      }).join('');\n    } else {\n      result.model = '';\n    }\n    return result;\n  }\n\n  function parseLinesLinuxDisplays(lines, depth) {\n    let displays = [];\n    let currentDisplay = {};\n    let is_edid = false;\n    let edid_raw = '';\n    let start = 0;\n    for (let i = 1; i < lines.length; i++) {        // start with second line\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0] && lines[i].toLowerCase().indexOf(' connected ') !== -1) {        // first line of new entry\n          if (Object.keys(currentDisplay).length > 0) {         // push last display to array\n            displays.push(currentDisplay);\n            currentDisplay = {};\n          }\n          let parts = lines[i].split(' ');\n          currentDisplay.connection = parts[0];\n          currentDisplay.main = (parts[2] === 'primary');\n          currentDisplay.builtin = (parts[0].toLowerCase().indexOf('edp') >= 0)\n        }\n\n        // try to read EDID information\n        if (is_edid) {\n          if (lines[i].search(/\\S|$/) > start) {\n            edid_raw += lines[i].toLowerCase().trim();\n          } else {\n            // parsen EDID\n            let edid_decoded = parseLinesLinuxEdid(edid_raw);\n            currentDisplay.model = edid_decoded.model;\n            currentDisplay.resolutionx = edid_decoded.resolutionx;\n            currentDisplay.resolutiony = edid_decoded.resolutiony;\n            currentDisplay.sizex = edid_decoded.sizex;\n            currentDisplay.sizey = edid_decoded.sizey;\n            currentDisplay.pixeldepth = depth;\n            is_edid = false;\n          }\n        }\n        if (lines[i].toLowerCase().indexOf('edid:') !== -1) {\n          is_edid = true;\n          start = lines[i].search(/\\S|$/);\n        }\n      }\n    }\n\n    // pushen displays\n    if (Object.keys(currentDisplay).length > 0) {         // still information there\n      displays.push(currentDisplay);\n    }\n    return displays\n  }\n\n  // function starts here\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED)\n        }\n        reject(error);\n      }\n      let result = {\n        controllers: [],\n        displays: []\n      };\n      if (_darwin) {\n        let cmd = 'system_profiler SPDisplaysDataType';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result = parseLinesDarwin(lines);\n          }\n          if (callback) {\n            callback(result)\n          }\n          resolve(result);\n        })\n      }\n      if (_linux) {\n        let cmd = 'lspci -vvv  2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.controllers = parseLinesLinuxControllers(lines);\n          }\n          let cmd = \"xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'\";\n          exec(cmd, function (error, stdout) {\n            let depth = 0;\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              depth = parseInt(lines[0]) || 0;\n            }\n            let cmd = 'xrandr --verbose 2>/dev/null';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.displays = parseLinesLinuxDisplays(lines, depth);\n              }\n              if (callback) {\n                callback(result)\n              }\n              resolve(result);\n            })\n          })\n        })\n      }\n    });\n  });\n}\n\nexports.graphics = graphics;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/filesystem.js":"'use strict';\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nlet _fs_speed = {};\nlet _disk_io = {};\n\n// --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux || _darwin) {\n        let cmd = (_darwin ? \"df -lkP | grep ^/\" : \"df -lkPT | grep ^/\");\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            //lines.splice(0, 1);\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.replace(/ +/g, \" \").split(' ');\n                data.push({\n                  'fs': line[0],\n                  'type': (_linux ? line[1] : 'HFS'),\n                  'size': parseInt((_linux ? line[2] : line[1])) * 1024,\n                  'used': parseInt((_linux ? line[3] : line[2])) * 1024,\n                  'use': parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),\n                  'mount': line[line.length - 1]\n                })\n              }\n            });\n          }\n          if (callback) {\n            callback(data)\n          }\n          resolve(data);\n        });\n      }\n      if (_windows) {\n        exec('wmic logicaldisk get Caption,FileSystem,FreeSpace,Size', function (error, stdout) {\n          let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n          lines.forEach(function (line) {\n            if (line !== '') {\n              line = line.trim().split(/\\s\\s+/);\n              data.push({\n                'fs': line[0],\n                'type': line[1],\n                'size': line[3],\n                'used': parseInt(line[3]) - parseInt(line[2]),\n                'use': parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),\n                'mount': line[0]\n              })\n            }\n          });\n          if (callback) {\n            callback(data)\n          }\n          resolve(data);\n        });\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize;\n\n// --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10))\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n        if (parts.length > 1) {\n          if (!devices[i]) devices[i] = {\n            name: '',\n            identifier: '',\n            type: 'disk',\n            fstype: '',\n            mount: '',\n            size: 0,\n            physical: 'HDD',\n            uuid: '',\n            label: '',\n            model: '',\n            serial: '',\n            removable: false,\n            protocol: ''\n          };\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) devices[i].identifier = parts[1];\n          if ('DEVICENODE' === parts[0]) devices[i].name = parts[1];\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) devices[i].label = parts[1];\n          }\n          if ('PROTOCOL' === parts[0]) devices[i].protocol = parts[1];\n          if ('DISKSIZE' === parts[0]) devices[i].size = parseBytes(parts[1]);\n          if ('FILESYSTEMPERSONALITY' === parts[0]) devices[i].fstype = parts[1];\n          if ('MOUNTPOINT' === parts[0]) devices[i].mount = parts[1];\n          if ('VOLUMEUUID' === parts[0]) devices[i].uuid = parts[1];\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'CD/DVD';\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') devices[i].physical = 'SSD';\n          if ('VIRTUAL' === parts[0]) devices[i].type = 'virtual';\n          if ('REMOVABLEMEDIA' === parts[0]) devices[i].removable = (parts[1] === 'Removable');\n          if ('PARTITIONTYPE' === parts[0]) devices[i].type = 'part';\n          if ('DEVICE/MEDIANAME' === parts[0]) devices[i].model = parts[1];\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n\n  lines.filter(line => line !== '').forEach((line) => {\n    let disk = JSON.parse(line);\n    data.push({\n      'name': disk.name,\n      'type': disk.type,\n      'fstype': disk.fstype,\n      'mount': disk.mountpoint,\n      'size': parseInt(disk.size),\n      'physical': (disk.type === 'disk' ? (disk.rota === '0' ? 'SSD' : 'HDD') : (disk.type === 'rom' ? 'CD/DVD' : '')),\n      'uuid': disk.uuid,\n      'label': disk.label,\n      'model': disk.model,\n      'serial': disk.serial,\n      'removable': disk.rm === '1',\n      'protocol': disk.tran\n    })\n  });\n\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString()\n    .replace(/NAME=/g, '{\"name\":')\n    .replace(/FSTYPE=/g, ',\"fstype\":')\n    .replace(/TYPE=/g, ',\"type\":')\n    .replace(/SIZE=/g, ',\"size\":')\n    .replace(/MOUNTPOINT=/g, ',\"mountpoint\":')\n    .replace(/UUID=/g, ',\"uuid\":')\n    .replace(/ROTA=/g, ',\"rota\":')\n    .replace(/RO=/g, ',\"ro\":')\n    .replace(/RM=/g, ',\"rm\":')\n    .replace(/TRAN=/g, ',\"tran\":')\n    .replace(/SERIAL=/g, ',\"serial\":')\n    .replace(/LABEL=/g, ',\"label\":')\n    .replace(/MODEL=/g, ',\"model\":')\n    .replace(/OWNER=/g, ',\"owner\":')\n    .replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec(\"lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER\", function (error, stdout) {\n          let data = [];\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n            if (callback) {\n              callback(data)\n            }\n            resolve(data);\n          } else {\n            exec(\"lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER\", function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n              }\n              if (callback) {\n                callback(data)\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        exec(\"diskutil info -all\", function (error, stdout) {\n          let data = [];\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            // parse lines into temp array of devices\n            data = parseDevices(lines);\n          }\n          if (callback) {\n            callback(data)\n          }\n          resolve(data);\n        });\n      }\n      if (_windows) {\n        exec('wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /format:csv', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n            lines.forEach(function (line) {\n              if (line !== '') {\n                line = line.replace('\\r', '').split(',');\n                data.push({\n                  name: line[7],\n                  identifier: line[1],\n                  type: 'disk',\n                  fstype: line[5].toLowerCase(),\n                  mount: line[1],\n                  size: line[8],\n                  physical: line[4] === '5' ? 'CD/DVD' : 'HDD',\n                  uuid: line[10],\n                  label: line[9],\n                  model: '',\n                  serial: line[10],\n                  removable: line[4] === '2',\n                  protocol: ''\n                });\n              }\n            });\n          }\n          if (callback) {\n            callback(data)\n          }\n          resolve(data);\n        });\n      }\n    });\n  });\n}\n\nexports.blockDevices = blockDevices;\n\n// --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: -1,\n    wx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = -1;\n    _fs_speed.wx_sec = -1;\n    _fs_speed.tx_sec = -1;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n  return result;\n}\n\nfunction fsStats(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED)\n        }\n        reject(error);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: -1,\n        wx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n\n      let rx = 0;\n      let wx = 0;\n      if ((_fs_speed && !_fs_speed.ms) || (_fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500)) {\n        if (_linux) {\n//  \t\t  exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec(\"lsblk | grep /\", function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.replace(/[├─│└]+/g, \"\").trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) fs_filter.push(line[0])\n                }\n              });\n\n              let output = fs_filter.join('|');\n              exec(\"cat /proc/diskstats | egrep '\" + output + \"'\", function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n                    if (line !== '') {\n                      line = line.replace(/ +/g, \" \").split(' ');\n\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n                if (callback) {\n                  callback(result)\n                }\n                resolve(result);\n              })\n            } else {\n              if (callback) {\n                callback(result)\n              }\n              resolve(result);\n            }\n          })\n        }\n        if (_darwin) {\n          exec(\"ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics' | tr -cd '01234567890,\\n' | awk -F',' '{print $3, $10}'\", function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(' ');\n\n                  rx += parseInt(line[0]);\n                  wx += parseInt(line[1]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n            if (callback) {\n              callback(result)\n            }\n            resolve(result);\n          })\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n        if (callback) {\n          callback(result)\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: -1,\n    wIO_sec: -1,\n    tIO_sec: -1,\n    ms: 0\n  };\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = -1;\n    _disk_io.wIO_sec = -1;\n    _disk_io.tIO_sec = -1;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n  return result;\n}\n\nfunction disksIO(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) {\n          callback(NOT_SUPPORTED)\n        }\n        reject(error);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: -1,\n        wIO_sec: -1,\n        tIO_sec: -1,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n\n      if ((_disk_io && !_disk_io.ms) || (_disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500)) {\n        if (_linux) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/│ └─//' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = \"for mount in `lsblk | grep ' disk ' | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) return;\n\n                // sum r/wIO of all disks to compute all disks IO\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n              });\n              result = calcDiskIO(rIO, wIO);\n\n              if (callback) {\n                callback(result)\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result)\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec(\"ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics' | tr -cd '01234567890,\\n' | awk -F',' '{print $1, $11}'\", function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(' ');\n\n                  rIO += parseInt(line[1]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO);\n            }\n            if (callback) {\n              callback(result)\n            }\n            resolve(result);\n          })\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n        if (callback) {\n          callback(result)\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/network.js":"'use strict';\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nlet _network = {};\nlet _default_iface;\n\nfunction getDefaultNetworkInterface() {\n\n  if (!_default_iface) {\n    let ifacename = '';\n    let cmd = (_linux ? \"route 2>/dev/null | grep default | awk '{print $8}'\" : \"route get 0.0.0.0 2>/dev/null | grep interface: | awk '{print $2}'\");\n    let result = execSync(cmd);\n    ifacename = result.toString().split('\\n')[0];\n\n    if (!ifacename) {         // fallback - \"first\" external interface\n      const sortObject = o => Object.keys(o).sort().reduce((r, k) => (r[k] = o[k], r), {});\n\n      let ifaces = sortObject(os.networkInterfaces());\n\n      for (let dev in ifaces) {\n        if (ifaces.hasOwnProperty(dev)) {\n          ifaces[dev].forEach(function (details) {\n            if (details && details.internal === false) {\n              ifacename = ifacename || dev;\n            }\n          })\n        }\n      }\n    }\n    if (ifacename) _default_iface = ifacename;\n  }\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result) }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction networkInterfaces(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaces = os.networkInterfaces();\n      let result = [];\n\n      for (let dev in ifaces) {\n        let ip4 = '';\n        let ip6 = '';\n        let mac = '';\n        if (ifaces.hasOwnProperty(dev)) {\n          ifaces[dev].forEach(function (details) {\n            if (details.family === 'IPv4') {\n              ip4 = details.address\n            }\n            if (details.family === 'IPv6') {\n              ip6 = details.address\n            }\n            mac = details.mac\n          });\n          let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : null;\n          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })\n        }\n      }\n      if (callback) { callback(result) }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx, tx, operstate) {\n  let result = {\n    iface: iface,\n    operstate: operstate,\n    rx: 0,\n    tx: 0,\n    rx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.rx = rx;\n    result.tx = tx;\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx - _network[iface].rx) / (result.ms / 1000);\n    result.tx_sec = (tx - _network[iface].tx) / (result.ms / 1000);\n    _network[iface].rx = rx;\n    _network[iface].tx = tx;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.tx = tx;\n    if (!_network[iface]) _network[iface] = {};\n    _network[iface].rx = rx;\n    _network[iface].tx = tx;\n    _network[iface].rx_sec = -1;\n    _network[iface].tx_sec = -1;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n  }\n  return result;\n}\n\nfunction networkStats(iface, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(iface) && !callback) {\n    callback = iface;\n    iface = '';\n  }\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      _default_iface = _default_iface || getDefaultNetworkInterface();\n      iface = iface || _default_iface; // (_darwin ? 'en0' : 'eth0');\n\n      let result = {\n        iface: iface,\n        operstate: 'unknown',\n        rx: 0,\n        tx: 0,\n        rx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx = 0;\n      let tx = 0;\n\n      let cmd, lines, stats;\n      if (!_network[iface] || (_network[iface] && !_network[iface].ms) || (_network[iface] && _network[iface].ms && Date.now() - _network[iface].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + iface)) {\n            cmd =\n              \"cat /sys/class/net/\" + iface + \"/operstate; \" +\n              \"cat /sys/class/net/\" + iface + \"/statistics/rx_bytes; \" +\n              \"cat /sys/class/net/\" + iface + \"/statistics/tx_bytes; \";\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx = parseInt(lines[1]);\n                tx = parseInt(lines[2]);\n\n                result = calcNetworkSpeed(iface, rx, tx, operstate);\n\n              }\n              if (callback) { callback(result) }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result) }\n            resolve(result);\n          }\n        }\n        if (_darwin) {\n          cmd = \"ifconfig \" + iface + \" | grep 'status'\";\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = \"netstat -bI \" + iface;\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, \" \").split(' ');\n                  rx = parseInt(stats[6]);\n                  tx = parseInt(stats[9]);\n\n                  result = calcNetworkSpeed(iface, rx, tx, operstate);\n                }\n              }\n              if (callback) { callback(result) }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx = _network[iface].rx;\n        result.tx = _network[iface].tx;\n        result.rx_sec = _network[iface].rx_sec;\n        result.tx_sec = _network[iface].tx_sec;\n        result.ms = _network[iface].last_ms;\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = [];\n      if (_linux) {\n        let cmd = \"netstat -tuna | grep 'ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\\\\|VERBUNDEN'\";\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, \" \").split(' ');\n              if (line.length >= 6) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                if (connstate === 'VERBUNDEN') connstate = 'ESTABLISHED';\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate\n                  })\n                }\n              }\n            });\n            if (callback) {\n              callback(result)\n            }\n            resolve(result);\n          } else {\n            cmd = \"ss -tuna | grep 'ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING'\";\n            exec(cmd, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, \" \").split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') connstate = 'ESTABLISHED';\n                    if (connstate === 'TIME-WAIT') connstate = 'TIME_WAIT';\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localaddress: localip,\n                        localport: localport,\n                        peeraddress: peerip,\n                        peerport: peerport,\n                        state: connstate\n                      })\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result)\n              }\n              resolve(result);\n            })\n          }\n        })\n      }\n      if (_darwin) {\n        let cmd = \"netstat -nat | grep 'ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN'\";\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n\n            let lines = stdout.toString().split('\\n');\n\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, \" \").split(' ');\n              if (line.length >= 6) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split('.');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join('.');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split('.');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join('.');\n                }\n                let connstate = line[5];\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate\n                  })\n                }\n              }\n            });\n            if (callback) {\n              callback(result)\n            }\n            resolve(result);\n          }\n        })\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/processes.js":"'use strict';\n// ==================================================================================\n// processes.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 10. Processes\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nlet _process_cpu = {\n  all: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\n\n// --------------------------\n// PS - services\n// pass a comma separated string with services to check (mysql, apache, postgresql, ...)\n// this function gives an array back, if the services are running.\n\nfunction services(srv, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(srv) && !callback) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      srv = srv.trim().replace(/,+/g, \" \").replace(/  +/g, \" \").replace(/ +/g, \"|\");\n      let srvs = srv.split('|');\n      let comm = (_darwin) ? \"ps -caxm -o pcpu,pmem,comm\" : \"ps axo pcpu,pmem,comm\";\n      let data = [];\n      if (srv !== '' && srvs.length > 0) {\n        exec(comm + \" | grep -v grep | egrep '\" + srv + \"'\", function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/ +/g, \" \").replace(/,+/g, \".\").split('\\n');\n            srvs.forEach(function (srv) {\n              let ps = lines.filter(function (e) {\n                return e.indexOf(srv) !== -1\n              });\n              data.push({\n                'name': srv,\n                'running': ps.length > 0,\n                'pcpu': parseFloat((ps.reduce(function (pv, cv) {\n                  return pv + parseFloat(cv.trim().split(' ')[0]);\n                }, 0)).toFixed(2)),\n                'pmem': parseFloat((ps.reduce(function (pv, cv) {\n                  return pv + parseFloat(cv.trim().split(' ')[1]);\n                }, 0)).toFixed(2))\n              })\n            });\n            if (callback) { callback(data) }\n            resolve(data);\n          } else {\n            srvs.forEach(function (srv) {\n              data.push({\n                'name': srv,\n                'running': false,\n                'pcpu': 0,\n                'pmem': 0\n              })\n            });\n            if (callback) { callback(data) }\n            resolve(data);\n          }\n        });\n      } else {\n        if (callback) { callback(data) }\n        resolve(data);\n      }\n    });\n  });\n}\n\nexports.services = services;\n\n// --------------------------\n// running processes\n\nfunction processes(callback) {\n\n  let parsedhead = [];\n\n  function parseHead(head, rights) {\n    let space = (rights > 0);\n    let count = 1;\n    let from = 0;\n    let to = 0;\n    let result = [];\n    for (let i = 0; i < head.length; i++) {\n      if (count <= rights) {\n        if (head[i] === ' ' && !space) {\n          to = i - 1;\n          result.push({\n            from: from,\n            to: to + 1,\n            cap: head.substring(from, to + 1)\n          });\n          from = to + 2;\n          count++;\n        }\n        space = head[i] === ' ';\n      } else {\n        if (head[i] !== ' ' && space) {\n          to = i - 1;\n          if (from < to) {\n            result.push({\n              from: from,\n              to: to,\n              cap: head.substring(from, to)\n            });\n          }\n          from = to + 1;\n          count++;\n        }\n        space = head[i] === ' ';\n      }\n    }\n    to = 1000;\n    result.push({\n      from: from,\n      to: to,\n      cap: head.substring(from, to)\n    });\n    return result;\n\n  }\n\n  function parseLine(line) {\n    let offset = 0;\n    let offset2 = 0;\n\n    function checkColumn(i) {\n      offset = offset2;\n      offset2 = line.substring(parsedhead[i].to + offset, 1000).indexOf(' ')\n//      if (line.substring(parsedhead[i].to + offset, parsedhead[i].to + offset + 1) !== ' ') {\n//        offset2++;\n//      }\n    }\n\n    checkColumn(0);\n    let pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));\n    checkColumn(1);\n    let pcpu = parseFloat(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2).replace(/,/g, \".\"));\n    checkColumn(2);\n    let pmem = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, \".\"));\n    checkColumn(3);\n    let priority = parseInt(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2));\n    checkColumn(4);\n    let vsz = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));\n    checkColumn(5);\n    let rss = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));\n    checkColumn(6);\n    let nice = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));\n    checkColumn(7);\n    let started = line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2).trim();\n    checkColumn(8);\n    let state = line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim();\n    state = (state[0] === 'R' ? 'running' : (state[0] === 'S' ? 'sleeping' : (state[0] === 'T' ? 'stopped' : (state[0] === 'W' ? 'paging' : (state[0] === 'X' ? 'dead' : (state[0] === 'Z' ? 'zombie' : ((state[0] === 'D' || state[0] === 'U') ? 'blocked' : 'unknown')))))));\n    checkColumn(9);\n    let tty = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();\n    if (tty === '?' || tty === '??') tty = '';\n    checkColumn(10);\n    let user = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();\n    checkColumn(11);\n    let command = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim().replace(/\\[/g, \"\").replace(/]/g, \"\");\n\n    return ({\n      pid: pid,\n      pcpu: pcpu,\n      pcpuu: 0,\n      pcpus: 0,\n      pmem: pmem,\n      priority: priority,\n      mem_vsz: vsz,\n      mem_rss: rss,\n      nice: nice,\n      started: started,\n      state: state,\n      tty: tty,\n      user: user,\n      command: command\n    })\n  }\n\n  function parseProcesses(lines) {\n    let result = [];\n    if (lines.length > 1) {\n      let head = lines[0];\n      parsedhead = parseHead(head, 8);\n      lines.shift();\n      lines.forEach(function (line) {\n        if (line.trim() !== '') {\n          result.push(parseLine(line));\n        }\n      });\n    }\n    return result;\n  }\n\n  function parseProcStat(line) {\n    let parts = line.replace(/ +/g, \" \").split(' ');\n    let user = (parts.length >= 2 ? parseInt(parts[1]) : 0);\n    let nice = (parts.length >= 3 ? parseInt(parts[2]) : 0);\n    let system = (parts.length >= 4 ? parseInt(parts[3]) : 0);\n    let idle = (parts.length >= 5 ? parseInt(parts[4]) : 0);\n    let iowait = (parts.length >= 6 ? parseInt(parts[5]) : 0);\n    let irq = (parts.length >= 7 ? parseInt(parts[6]) : 0);\n    let softirq = (parts.length >= 8 ? parseInt(parts[7]) : 0);\n    let steal = (parts.length >= 9 ? parseInt(parts[8]) : 0);\n    let guest = (parts.length >= 10 ? parseInt(parts[9]) : 0);\n    let guest_nice = (parts.length >= 11 ? parseInt(parts[10]) : 0);\n    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;\n  }\n\n  function parseProcPidStat(line, all) {\n    let statparts = line.replace(/ +/g, \" \").split(')');\n    if (statparts.length >= 2) {\n      let parts = statparts[1].split(' ');\n      if (parts.length >= 16) {\n        let pid = parseInt(statparts[0].split(' ')[0]);\n        let utime = parseInt(parts[12]);\n        let stime = parseInt(parts[13]);\n        let cutime = parseInt(parts[14]);\n        let cstime = parseInt(parts[15]);\n\n        // calc\n        let pcpuu = 0;\n        let pcpus = 0;\n        if (_process_cpu.all > 0 && _process_cpu.list[pid]) {\n          pcpuu = (utime + cutime - _process_cpu.list[pid].utime - _process_cpu.list[pid].cutime) / (all - _process_cpu.all) * 100; // user\n          pcpus = (stime + cstime - _process_cpu.list[pid].stime - _process_cpu.list[pid].cstime) / (all - _process_cpu.all) * 100; // system\n        } else {\n          pcpuu = (utime + cutime) / (all) * 100; // user\n          pcpus = (stime + cstime) / (all) * 100; // system\n        }\n        return {\n          pid: pid,\n          utime: utime,\n          stime: stime,\n          cutime: cutime,\n          cstime: cstime,\n          pcpuu: pcpuu,\n          pcpus: pcpus\n        }\n      } else {\n        return {\n          pid: 0,\n          utime: 0,\n          stime: 0,\n          cutime: 0,\n          cstime: 0,\n          pcpuu: 0,\n          pcpus: 0\n        }\n      }\n    } else {\n      return {\n        pid: 0,\n        utime: 0,\n        stime: 0,\n        cutime: 0,\n        cstime: 0,\n        pcpuu: 0,\n        pcpus: 0\n      }\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n      let result = {\n        all: 0,\n        running: 0,\n        blocked: 0,\n        sleeping: 0,\n        list: []\n      };\n\n      let cmd = \"\";\n\n      if ((_process_cpu.ms && Date.now() - _process_cpu.ms >= 500) || _process_cpu.ms === 0) {\n        if (_linux) cmd = \"ps axo pid:10,pcpu:6,pmem:6,pri:5,vsz:10,rss:10,ni:5,start:20,state:20,tty:20,user:20,command\";\n        if (_darwin) cmd = \"ps acxo pid,pcpu,pmem,pri,vsz,rss,nice,start,state,tty,user,command -r\";\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            result.list = parseProcesses(stdout.toString().split('\\n'));\n            result.all = result.list.length;\n            result.running = result.list.filter(function (e) {\n              return e.state === 'running'\n            }).length;\n            result.blocked = result.list.filter(function (e) {\n              return e.state === 'blocked'\n            }).length;\n            result.sleeping = result.list.filter(function (e) {\n              return e.state === 'sleeping'\n            }).length;\n\n            if (_linux) {\n              // calc process_cpu - ps is not accurate in linux!\n              cmd = \"cat /proc/stat | grep 'cpu '\";\n              for (let i = 0; i < result.list.length; i++) {\n                cmd += (';cat /proc/' + result.list[i].pid + '/stat')\n              }\n              exec(cmd, function (error, stdout) {\n                let curr_processes = stdout.toString().split('\\n');\n\n                // first line (all - /proc/stat)\n                let all = parseProcStat(curr_processes.shift());\n\n                // process\n                let list_new = {};\n                let resultProcess = {};\n                for (let i = 0; i < curr_processes.length; i++) {\n                  resultProcess = parseProcPidStat(curr_processes[i], all);\n\n                  if (resultProcess.pid) {\n\n                    // store pcpu in outer array\n                    let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                    if (listPos >= 0) {\n                      result.list[listPos].pcpu = resultProcess.pcpuu + resultProcess.pcpus;\n                      result.list[listPos].pcpuu = resultProcess.pcpuu;\n                      result.list[listPos].pcpus = resultProcess.pcpus;\n                    }\n\n                    // save new values\n                    list_new[resultProcess.pid] = {\n                      pcpuu: resultProcess.pcpuu,\n                      pcpus: resultProcess.pcpus,\n                      utime: resultProcess.utime,\n                      stime: resultProcess.stime,\n                      cutime: resultProcess.cutime,\n                      cstime: resultProcess.cstime\n                    }\n                  }\n                }\n\n                // store old values\n                _process_cpu.all = all;\n                _process_cpu.list = list_new;\n                _process_cpu.ms = Date.now() - _process_cpu.ms;\n                _process_cpu.result = result;\n                if (callback) { callback(result) }\n                resolve(result);\n              })\n            } else {\n              if (callback) { callback(result) }\n              resolve(result);\n            }\n          }\n        });\n      } else {\n        if (callback) { callback(_process_cpu.result) }\n        resolve(_process_cpu.result);\n      }\n    });\n  });\n}\n\nexports.processes = processes;\n\n// --------------------------\n// PS - process load\n// get detailed information about a certain process\n// (PID, CPU-Usage %, Mem-Usage %)\n\nfunction processLoad(proc, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(proc) && !callback) {\n    callback = proc;\n    proc = '';\n  }\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = {\n        'proc': proc,\n        'pid': -1,\n        'cpu': 0,\n        'mem': 0\n      };\n\n      if (proc) {\n        exec(\"ps aux | grep \" + proc + \" | grep -v grep\", function (error, stdout) {\n          if (!error) {\n            let data = stdout.replace(/ +/g, \" \").split(' ');\n\n            if (data.length > 2) {\n              result = {\n                'proc': proc,\n                'pid': data[1],\n                'cpu': parseFloat(data[2].replace(',', '.')),\n                'mem': parseFloat(data[3].replace(',', '.'))\n              }\n            }\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.processLoad = processLoad;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/users.js":"'use strict';\n// ==================================================================================\n// users.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 11. Users/Sessions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\n// --------------------------\n// array of users online = sessions\n\nfunction parseUsers1(lines) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let w_first = true;\n  let w_header = [];\n  let w_pos = [];\n  let w_headerline = '';\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, \" \").split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: l[2],\n          time: l[3],\n          ip: (l && l.length > 4) ? l[4].replace(/\\(/g, \"\").replace(/\\)/g, \"\") : ''\n        })\n      } else {\n        // w part\n        if (w_first) {    // header\n          w_header = l;\n          w_headerline = line;\n          w_header.forEach(function (item) {\n            w_pos.push(line.indexOf(item))\n          });\n          w_first = false;\n        } else {\n          // split by w_pos\n          result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();\n          result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();\n          result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\\(/g, \"\").replace(/\\)/g, \"\").trim();\n          result_w.command = line.substring(w_pos[7], 1000).trim();\n          // find corresponding 'who' line\n          who_line = result_who.filter(function (obj) {\n            return (obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty)\n          });\n          if (who_line.length === 1) {\n            result.push({\n              user: who_line[0].user,\n              tty: who_line[0].tty,\n              date: who_line[0].date,\n              time: who_line[0].time,\n              ip: who_line[0].ip,\n              command: result_w.command\n            })\n          }\n        }\n      }\n    }\n  });\n  return result;\n}\n\nfunction parseUsers2(lines) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, \" \").split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: (\"\" + new Date().getFullYear()) + '-' + (\"0\" + (\"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC\".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + '-' + (\"0\" + l[3]).slice(-2),\n          time: l[4],\n        })\n      } else {\n        // w part\n        // split by w_pos\n        result_w.user = l[0];\n        result_w.tty = l[1];\n        result_w.ip = (l[2] !== '-') ? l[2] : '';\n        result_w.command = l.slice(5, 1000).join(' ');\n        // find corresponding 'who' line\n        who_line = result_who.filter(function (obj) {\n          return (obj.user === result_w.user && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty))\n        });\n        if (who_line.length === 1) {\n          result.push({\n            user: who_line[0].user,\n            tty: who_line[0].tty,\n            date: who_line[0].date,\n            time: who_line[0].time,\n            ip: result_w.ip,\n            command: result_w.command\n          })\n        }\n      }\n    }\n  });\n  return result;\n}\n\nfunction users(callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = [];\n\n      // linux\n      if (_linux) {\n        exec(\"who --ips; echo '---'; w | tail -n +2\", function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsers1(lines);\n            if (result.length === 0) {\n              exec(\"who; echo '---'; w | tail -n +2\", function (error, stdout) {\n                if (!error) {\n                  // lines / split\n                  lines = stdout.toString().split('\\n');\n                  result = parseUsers1(lines);\n                  if (callback) { callback(result) }\n                  resolve(result);\n                } else {\n                  if (callback) { callback(result) }\n                  resolve(result);\n                }\n              });\n            } else {\n              if (callback) { callback(result) }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result) }\n            resolve(result);\n          }\n        });\n      }\n\n      if (_darwin) {\n        exec(\"who; echo '---'; w -ih\", function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsers2(lines);\n\n            if (callback) { callback(result) }\n            resolve(result);\n          } else {\n            if (callback) { callback(result) }\n            resolve(result);\n          }\n        });\n      }\n\n    });\n  });\n}\n\nexports.users = users;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/internet.js":"'use strict';\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = os.type();\n\nconst _linux = (_platform === 'Linux');\nconst _darwin = (_platform === 'Darwin');\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: -1\n      };\n      if (url) {\n        let t = Date.now();\n        let args = \" -I --connect-timeout 5 -m 5 \" + url + \" 2>/dev/null | head -n 1 | cut -d ' ' -f2\";\n        let cmd = \"curl\";\n        exec(cmd + args, function (error, stdout) {\n          let statusCode = parseInt(stdout.toString());\n          result.status = statusCode || 404;\n          result.ok = !error && (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n          result.ms = (result.ok ? Date.now() - t : -1);\n          if (callback) { callback(result) }\n          resolve(result);\n        })\n      } else {\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      let t = Date.now();\n      let cmd;\n      if (_linux) {\n        cmd = \"ping -c 2 -w 3 \" + host + \" | grep rtt | cut -d'/' -f4 | awk '{ print $3 }'\";\n      }\n      if (_darwin) {\n        cmd = \"ping -c 2 -t 3 \" + host + \" | grep avg | cut -d'/' -f4 | awk '{ print $3 }'\";\n      }\n\n      exec(cmd, function (error, stdout) {\n        let result = -1;\n        if (!error) {\n          result = parseFloat(stdout.toString());\n        }\n        if (callback) { callback(result) }\n        resolve(result);\n      })\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/docker.js":"'use strict';\n// ==================================================================================\n// docker.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2017\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. Docker\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst util = require('./util');\nconst  DockerSocket = require('./dockerSocket');\n\nlet _platform = os.type();\n\nconst _windows = (_platform === 'Windows_NT');\nconst NOT_SUPPORTED = 'not supported';\n\nlet _docker_container_stats = {};\nlet _docker_socket;\n\n\n// --------------------------\n// get containers (parameter all: get also inactive/exited containers)\n\nfunction dockerContainers(all, callback) {\n\n  function inContainers(containers, id) {\n    let filtered = containers.filter(obj => {\n      /**\n       * @namespace\n       * @property {string}  Id\n       */\n      return (obj.Id && (obj.Id === id))\n    });\n    return (filtered.length > 0);\n  }\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n\n      _docker_socket.listContainers(all, data => {\n        let docker_containers = {};\n        // let cmd = \"curl --unix-socket /var/run/docker.sock http:/containers/json\" + (all ? \"?all=1\" : \"\");\n        // exec(cmd, function (error, stdout) {\n        //   if (!error) {\n        try {\n          //       let jsonString = stdout.toString();\n          //       let docker_containers = JSON.parse(jsonString);\n          docker_containers = data;\n          if (docker_containers && Object.prototype.toString.call(docker_containers) === '[object Array]' && docker_containers.length > 0) {\n            docker_containers.forEach(function (element) {\n              /**\n               * @namespace\n               * @property {string}  Id\n               * @property {string}  Name\n               * @property {string}  Image\n               * @property {string}  ImageID\n               * @property {string}  Command\n               * @property {number}  Created\n               * @property {string}  State\n               * @property {Array}  Names\n               * @property {Array}  Ports\n               * @property {Array}  Mounts\n               */\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              result.push({\n                id: element.Id,\n                name: element.Name,\n                image: element.Image,\n                imageID: element.ImageID,\n                command: element.Command,\n                created: element.Created,\n                state: element.State,\n                ports: element.Ports,\n                mounts: element.Mounts,\n                // hostconfig: element.HostConfig,\n                // network: element.NetworkSettings\n              })\n            });\n          }\n        } catch (err) {\n        }\n        // }\n\n        // GC in _docker_container_stats\n        for (let key in _docker_container_stats) {\n          if (_docker_container_stats.hasOwnProperty(key)) {\n            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];\n          }\n        }\n        if (callback) { callback(result) }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.dockerContainers = dockerContainers;\n\n// --------------------------\n// helper functions for calculation of docker stats\n\nfunction docker_calcCPUPercent(cpu_stats, id) {\n  /**\n   * @namespace\n   * @property {object}  cpu_usage\n   * @property {number}  cpu_usage.total_usage\n   * @property {number}  system_cpu_usage\n   * @property {object}  cpu_usage\n   * @property {Array}  cpu_usage.percpu_usage\n   */\n\n  let cpuPercent = 0.0;\n  // calculate the change for the cpu usage of the container in between readings\n  let cpuDelta = cpu_stats.cpu_usage.total_usage - (_docker_container_stats[id] && _docker_container_stats[id].prev_CPU ? _docker_container_stats[id].prev_CPU : 0);\n  // calculate the change for the entire system between readings\n  let systemDelta = cpu_stats.system_cpu_usage - (_docker_container_stats[id] && _docker_container_stats[id].prev_system ? _docker_container_stats[id].prev_system : 0);\n\n  if (systemDelta > 0.0 && cpuDelta > 0.0) {\n    cpuPercent = (cpuDelta / systemDelta) * cpu_stats.cpu_usage.percpu_usage.length * 100.0;\n  }\n  if (!_docker_container_stats[id]) _docker_container_stats[id] = {};\n  _docker_container_stats[id].prev_CPU = cpu_stats.cpu_usage.total_usage;\n  _docker_container_stats[id].prev_system = cpu_stats.system_cpu_usage;\n\n  return cpuPercent\n}\n\nfunction docker_calcNetworkIO(networks) {\n  let rx;\n  let tx;\n  for (let key in networks) {\n    // skip loop if the property is from prototype\n    if (!networks.hasOwnProperty(key)) continue;\n\n    /**\n     * @namespace\n     * @property {number}  rx_bytes\n     * @property {number}  tx_bytes\n     */\n    let obj = networks[key];\n    rx = +obj.rx_bytes;\n    tx = +obj.tx_bytes;\n  }\n  return {\n    rx: rx,\n    tx: tx\n  }\n}\n\nfunction docker_calcBlockIO(blkio_stats) {\n  let result = {\n    r: 0,\n    w: 0\n  };\n\n  /**\n   * @namespace\n   * @property {Array}  io_service_bytes_recursive\n   */\n  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === '[object Array]' && blkio_stats.io_service_bytes_recursive.length > 0) {\n    blkio_stats.io_service_bytes_recursive.forEach(function (element) {\n      /**\n       * @namespace\n       * @property {string}  op\n       * @property {number}  value\n       */\n\n      if (element.op && element.op.toLowerCase() === 'read' && element.value) {\n        result.r += element.value;\n      }\n      if (element.op && element.op.toLowerCase() === 'write' && element.value) {\n        result.w += element.value;\n      }\n    })\n  }\n  return result;\n}\n\n// --------------------------\n// container stats (for one container)\n\nfunction dockerContainerStats(containerID, callback) {\n  containerID = containerID || '';\n  let result = {\n    id: containerID,\n    mem_usage: 0,\n    mem_limit: 0,\n    mem_percent: 0,\n    cpu_percent: 0,\n    pids: 0,\n    netIO: {\n      rx: 0,\n      wx: 0\n    },\n    blockIO: {\n      r: 0,\n      w: 0\n    }\n  };\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n      if (containerID) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getStats(containerID, data => {\n          // let cmd = \"curl --unix-socket /var/run/docker.sock http:/containers/\" + containerID + \"/stats?stream=0\";\n          // exec(cmd, function (error, stdout) {\n          //   if (!error) {\n          //     let jsonString = stdout.toString();\n          try {\n//              let stats = JSON.parse(jsonString);\n            let stats = data;\n            /**\n             * @namespace\n             * @property {Object}  memory_stats\n             * @property {number}  memory_stats.usage\n             * @property {number}  memory_stats.limit\n             * @property {Object}  cpu_stats\n             * @property {Object}  pids_stats\n             * @property {number}  pids_stats.current\n             * @property {Object}  networks\n             * @property {Object}  blkio_stats\n             */\n\n            if (!stats.message) {\n              result.mem_usage = (stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0);\n              result.mem_limit = (stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0);\n              result.mem_percent = (stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100.0 : 0);\n              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);\n              result.pids = (stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0);\n              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);\n              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);\n              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});\n              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});\n              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});\n              result.networks = (stats.networks ? stats.networks : {});\n            }\n          } catch (err) {\n          }\n          // }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerStats = dockerContainerStats;\n\n// --------------------------\n// container processes (for one container)\n\nfunction dockerContainerProcesses(containerID, callback) {\n  containerID = containerID || '';\n  let result = [];\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n      if (containerID) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getProcesses(containerID, data => {\n          /**\n           * @namespace\n           * @property {Array}  Titles\n           * @property {Array}  Processes\n           **/\n           try {\n            if (data && data.Titles && data.Processes) {\n              let titles = data.Titles.map(function(value) {\n                return value.toUpperCase();\n              });\n              let pos_pid = titles.indexOf('PID');\n              let pos_ppid = titles.indexOf('PPID');\n              let pos_pgid = titles.indexOf('PGID');\n              let pos_vsz = titles.indexOf('VSZ');\n              let pos_time = titles.indexOf('TIME');\n              let pos_elapsed = titles.indexOf('ELAPSED');\n              let pos_ni = titles.indexOf('NI');\n              let pos_ruser = titles.indexOf('RUSER');\n              let pos_user = titles.indexOf('USER');\n              let pos_rgroup = titles.indexOf('RGROUP');\n              let pos_group = titles.indexOf('GROUP');\n              let pos_stat = titles.indexOf('STAT');\n              let pos_rss = titles.indexOf('RSS');\n              let pos_command = titles.indexOf('COMMAND');\n\n              data.Processes.forEach(process => {\n                result.push({\n                  pid_host: (pos_pid >= 0 ? process[pos_pid] : ''),\n                  ppid: (pos_ppid >= 0 ? process[pos_ppid] : ''),\n                  pgid: (pos_pgid >= 0 ? process[pos_pgid] : ''),\n                  user: (pos_user >= 0 ? process[pos_user] : ''),\n                  ruser: (pos_ruser >= 0 ? process[pos_ruser] : ''),\n                  group: (pos_group >= 0 ? process[pos_group] : ''),\n                  rgroup: (pos_rgroup >= 0 ? process[pos_rgroup] : ''),\n                  stat: (pos_stat >= 0 ? process[pos_stat] : ''),\n                  time: (pos_time >= 0 ? process[pos_time] : ''),\n                  elapsed: (pos_elapsed >= 0 ? process[pos_elapsed] : ''),\n                  nice: (pos_ni >= 0 ? process[pos_ni] : ''),\n                  rss: (pos_rss >= 0 ? process[pos_rss] : ''),\n                  vsz: (pos_vsz >= 0 ? process[pos_vsz] : ''),\n                  command: (pos_command >= 0 ? process[pos_command] : '')\n                })\n              })\n            }\n          } catch (err) {\n          }\n          if (callback) { callback(result) }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result) }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerProcesses = dockerContainerProcesses;\n\nfunction dockerAll(callback) {\n  return new Promise((resolve, reject) => {\n    process.nextTick(() => {\n      if (_windows) {\n        let error = new Error(NOT_SUPPORTED);\n        if (callback) { callback(NOT_SUPPORTED) }\n        reject(error);\n      }\n      dockerContainers(true).then(result => {\n        if (result && Object.prototype.toString.call(result) === '[object Array]' && result.length > 0) {\n          let l = result.length;\n          result.forEach(function (element) {\n            dockerContainerStats(element.id).then(res => {\n              // include stats in array\n              element.mem_usage = res.mem_usage;\n              element.mem_limit = res.mem_limit;\n              element.mem_percent = res.mem_percent;\n              element.cpu_percent = res.cpu_percent;\n              element.pids = res.pids;\n              element.netIO = res.netIO;\n              element.blockIO = res.blockIO;\n              element.cpu_stats = res.cpu_stats;\n              element.precpu_stats = res.precpu_stats;\n              element.memory_stats = res.memory_stats;\n              element.networks = res.networks;\n\n              dockerContainerProcesses(element.id).then(processes => {\n                element.processes = processes;\n\n                l -= 1;\n                if (l === 0) {\n                  if (callback) { callback(result) }\n                  resolve(result);\n                }\n              });\n              // all done??\n            })\n          })\n        } else {\n          if (callback) { callback(result) }\n          resolve(result);\n        }\n      })\n    });\n  });\n}\n\nexports.dockerAll = dockerAll;\n","/home/travis/build/npmtest/node-npmtest-systeminformation/node_modules/systeminformation/lib/dockerSocket.js":"'use strict';\n\nconst net = require('net');\n\nclass DockerSocket {\n\n  listContainers(all, callback) {\n    try {\n\n      let socket = net.createConnection({path: '/var/run/docker.sock'});\n      let alldata = '';\n\n      socket.on(\"connect\", () => {\n        socket.write('GET http:/containers/json' + (all ? \"?all=1\" : \"\") + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on(\"data\", data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on(\"error\", () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf(\"\\r\\n\\r\\n\");\n        alldata = alldata.substring(startbody, 100000).replace(/[\\n\\r]/g, '');\n        socket = false;\n        callback(JSON.parse(alldata));\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  getStats(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({path: '/var/run/docker.sock'});\n        let alldata = '';\n\n        socket.on(\"connect\", () => {\n          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on(\"data\", data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on(\"error\", () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf(\"\\r\\n\\r\\n\");\n          alldata = alldata.substring(startbody, 100000).replace(/[\\n\\r]/g, '');\n          socket = false;\n          callback(JSON.parse(alldata));\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getProcesses(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({path: '/var/run/docker.sock'});\n        let alldata = '';\n\n        socket.on(\"connect\", () => {\n          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on(\"data\", data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on(\"error\", () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf(\"\\r\\n\\r\\n\");\n          alldata = alldata.substring(startbody, 100000).replace(/[\\n\\r]/g, '');\n          socket = false;\n          callback(JSON.parse(alldata));\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n}\n\nmodule.exports = DockerSocket;\n"}